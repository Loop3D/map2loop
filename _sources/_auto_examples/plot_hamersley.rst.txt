
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "_auto_examples/plot_hamersley.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download__auto_examples_plot_hamersley.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr__auto_examples_plot_hamersley.py:


============================
Hamersley, Western Australia
============================

.. GENERATED FROM PYTHON SOURCE LINES 6-21

.. code-block:: Python

    import time
    import os
    from map2loop.project import Project
    from map2loop.m2l_enums import VerboseLevel, Datatype
    from map2loop.sorter import (
        SorterAlpha,
        SorterAgeBased,
        SorterUseHint,
        SorterUseNetworkX,
        SorterMaximiseContacts,
        SorterObservationProjections,
    )
    from map2loop.sampler import SamplerSpacing
    from datetime import datetime








.. GENERATED FROM PYTHON SOURCE LINES 22-25

Set the region of interest for the project
-------------------------------------------
Define the bounding box for the ROI

.. GENERATED FROM PYTHON SOURCE LINES 25-59

.. code-block:: Python


    bbox_3d = {
        "minx": 515687.31005864,
        "miny": 7493446.76593407,
        "maxx": 562666.860106543,
        "maxy": 7521273.57407786,
        "base": -3200,
        "top": 3000,
    }

    # Specify minimum details (which Australian state, projection and bounding box
    # and output file)
    loop_project_filename = "wa_output.loop3d"
    proj = Project(
        use_australian_state_data="WA",
        working_projection="EPSG:28350",
        bounding_box=bbox_3d,
        verbose_level=VerboseLevel.NONE,
        loop_project_filename=loop_project_filename,
    )

    # Set the distance between sample points for arial and linestring geometry
    proj.set_sampler(Datatype.GEOLOGY, SamplerSpacing(200.0))
    proj.set_sampler(Datatype.FAULT, SamplerSpacing(200.0))

    # Choose which stratigraphic sorter to use or run_all with "take_best" flag to run them all
    proj.set_sorter(SorterAlpha())
    # proj.set_sorter(SorterAgeBased())
    # proj.set_sorter(SorterUseHint())
    # proj.set_sorter(SorterUseNetworkx())
    # proj.set_sorter(SorterMaximiseContacts())
    # proj.set_sorter(SorterObservationProjections())
    proj.run_all(take_best=True)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Unused keys from legacy format ['msc', 'msn', 'mst', 'mtc', 'mscm', 'mcom', 'minf', 'fdipdir_flag', 'deposit_dist']
    /opt/conda/lib/python3.11/site-packages/map2loop/map2model_wrapper.py:172: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
    You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
    A typical example is when you are setting values in a column of a DataFrame, like:

    df["col"][row_indexer] = value

    Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

      df[1][j] = [i.strip("()").replace(" ", "").split(",") for i in df[1][j]]
    /opt/conda/lib/python3.11/site-packages/map2loop/map2model_wrapper.py:172: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
    You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
    A typical example is when you are setting values in a column of a DataFrame, like:

    df["col"][row_indexer] = value

    Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

      df[1][j] = [i.strip("()").replace(" ", "").split(",") for i in df[1][j]]
    /opt/conda/lib/python3.11/site-packages/map2loop/map2model_wrapper.py:172: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
    You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
    A typical example is when you are setting values in a column of a DataFrame, like:

    df["col"][row_indexer] = value

    Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

      df[1][j] = [i.strip("()").replace(" ", "").split(",") for i in df[1][j]]
    /opt/conda/lib/python3.11/site-packages/map2loop/map2model_wrapper.py:172: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
    You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
    A typical example is when you are setting values in a column of a DataFrame, like:

    df["col"][row_indexer] = value

    Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

      df[1][j] = [i.strip("()").replace(" ", "").split(",") for i in df[1][j]]
    /opt/conda/lib/python3.11/site-packages/map2loop/map2model_wrapper.py:172: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
    You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
    A typical example is when you are setting values in a column of a DataFrame, like:

    df["col"][row_indexer] = value

    Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

      df[1][j] = [i.strip("()").replace(" ", "").split(",") for i in df[1][j]]
    /opt/conda/lib/python3.11/site-packages/map2loop/map2model_wrapper.py:172: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
    You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
    A typical example is when you are setting values in a column of a DataFrame, like:

    df["col"][row_indexer] = value

    Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

      df[1][j] = [i.strip("()").replace(" ", "").split(",") for i in df[1][j]]
    /opt/conda/lib/python3.11/site-packages/map2loop/map2model_wrapper.py:172: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
    You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
    A typical example is when you are setting values in a column of a DataFrame, like:

    df["col"][row_indexer] = value

    Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

      df[1][j] = [i.strip("()").replace(" ", "").split(",") for i in df[1][j]]
    /opt/conda/lib/python3.11/site-packages/map2loop/map2model_wrapper.py:172: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
    You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
    A typical example is when you are setting values in a column of a DataFrame, like:

    df["col"][row_indexer] = value

    Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

      df[1][j] = [i.strip("()").replace(" ", "").split(",") for i in df[1][j]]
    /opt/conda/lib/python3.11/site-packages/map2loop/map2model_wrapper.py:172: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
    You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
    A typical example is when you are setting values in a column of a DataFrame, like:

    df["col"][row_indexer] = value

    Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

      df[1][j] = [i.strip("()").replace(" ", "").split(",") for i in df[1][j]]
    Best sorter SorterAgeBased calculated contact length of 286560.51738879026
    Cannot calculate thickness between Fortescue_Group and Bunjinah_Formation
    Cannot calculate thickness between Bunjinah_Formation and Boolgeeda_Iron_Formation
    Cannot calculate thickness between Boolgeeda_Iron_Formation and Woongarra_Rhyolite
    Cannot calculate thickness between Woongarra_Rhyolite and Weeli_Wolli_Formation
    Cannot calculate thickness between Weeli_Wolli_Formation and Brockman_Iron_Formation
    Cannot calculate thickness between Wittenoom_Formation and Marra_Mamba_Iron_Formation
    Cannot calculate thickness between Marra_Mamba_Iron_Formation and Turee_Creek_Group
    /opt/conda/lib/python3.11/site-packages/map2loop/sampler.py:137: FutureWarning: The behavior of DataFrame concatenation with empty or all-NA entries is deprecated. In a future version, this will no longer exclude empty or all-NA columns when determining the result dtypes. To retain the old behavior, exclude the relevant entries before the concat operation.
      df = pandas.concat([df, df2])




.. GENERATED FROM PYTHON SOURCE LINES 60-62

Visualise the map2loop results
-------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 62-64

.. code-block:: Python


    proj.map_data.basal_contacts.plot()



.. image-sg:: /_auto_examples/images/sphx_glr_plot_hamersley_001.png
   :alt: plot hamersley
   :srcset: /_auto_examples/images/sphx_glr_plot_hamersley_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: >




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 14.802 seconds)


.. _sphx_glr_download__auto_examples_plot_hamersley.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_hamersley.ipynb <plot_hamersley.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_hamersley.py <plot_hamersley.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
